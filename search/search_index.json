{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Container Technology 2025","text":""},{"location":"#containerized-application-for-data-science","title":"Containerized Application for Data Science","text":"<p>Motivation A key aspect of a data scientist\u2019s work involves managing and maintaining a reliable development environment. Keeping the development environment up-to-date and closely aligned with the production environment ensures smoother workflows. When these environments diverge, issues can quickly arise. In larger settings, proficiency with CI/CD pipelines and DevOps practices becomes highly beneficial. A data scientist\u2019s primary goal is to deliver solutions that are easy to integrate and deploy into production seamlessly.</p> <p></p>"},{"location":"#course-summary","title":"Course Summary","text":""},{"location":"#overview-container-technology","title":"Overview Container Technology","text":"<ul> <li>Overview Containe Architecture</li> </ul>"},{"location":"#part-1-installation","title":"Part 1 installation","text":"<ul> <li>Install Native Python Learn how to install and configure a native Python environment on your system, enabling the use of Python directly without additional tools.</li> <li>Install Conda Environment A guide to setting up Conda, a versatile environment and package manager, which helps manage dependencies and isolate projects seamlessly.</li> <li>Install Docker Desktop Step-by-step instructions for installing Docker Desktop on Windows, providing a containerized environment for consistent and reproducible workflows.</li> </ul>"},{"location":"#part-2-docker-jupyter","title":"Part 2 Docker Jupyter","text":"<p>This section dives into leveraging Docker for data science, with a focus on JupyterLab and Docker Compose for streamlined workflows. * Install Docker For Data Science Instructions for setting up a Docker environment specifically designed for data science tasks, complete with JupyterLab. * Explain DataScience Dockerfile An in-depth explanation of the Dockerfile designed for data science, detailing the configurations and tools included to optimize productivity. * Migrate to Docker compose Learn how to use Docker Compose to manage multi-container applications, making it easier to handle complex setups for data science projects.</p>"},{"location":"overview/architecture/","title":"Section 1 Overview Container Architecture","text":""},{"location":"overview/architecture/#containers-vs-virtual-machines","title":"Containers vs Virtual Machines","text":"<p>Virtual machines (VMs) and containers are two modern frameworks that have significantly transformed how virtualization is perceived in the software industry. Both enable the movement of workloads across different physical devices, and they are often used together rather than being mutually exclusive.</p> <p>The main distinction between containers and virtual machines lies in how they implement virtualization. Virtual machines virtualize an entire system, including the hardware, by using a hypervisor. This means that each VM includes its own operating system and resources. In contrast, containers virtualize only the software layers above the operating system, sharing the host OS\u2019s kernel. As a result, containers are more lightweight and efficient, but they rely on the host system\u2019s operating environment for execution.</p> <p></p> <p>A container as a virtual machine has isolation, that is, a space reserved for data processing, authorization as root, can mount file systems and more. However, unlike virtual machines that are managed with separate operating systems, the containers share the kernel of the host system with other containers, as shown in the following diagrams.</p> <p>What is a hypervisor</p> <p>A hypervisor is specialized software that emulates a client PC along with all its hardware resources. It operates on physical computers, also known as host machines. There are two types of hypervisors: hosted and bare-metal. A hosted hypervisor relies on an existing operating system to run and does not directly manage hardware drivers. In contrast, a bare-metal hypervisor runs directly on the host hardware, without needing an underlying operating system.</p>"},{"location":"overview/architecture/#why-use-docker-containers-for-data-development-with-jupyter-lab","title":"Why use Docker containers for Data  development with Jupyter lab?","text":"<p> Docker containers for data development with Jupyter Lab offer a consistent, isolated environment that ensures reproducibility, simplifies dependency management, and allows easy sharing of setups across different systems. Containers streamline the setup process, avoid version conflicts, and ensure that the development environment closely matches production.</p> <p>Using Docker containers for data development with Jupyter Lab provides several key advantages:</p> <ol> <li> <p>Isolation: Docker containers create an isolated environment for your Jupyter Lab and its dependencies, preventing conflicts with other software or projects running on your system.</p> </li> <li> <p>Reproducibility: Docker ensures that the environment is the same across different machines, which means that code and notebooks developed in one container will work the same way on any other system with the same container.</p> </li> <li> <p>Consistency: Containers encapsulate all dependencies and configurations, so your development environment is consistent, regardless of where the container is run (locally, in the cloud, or on a server).</p> </li> <li> <p>Easy Setup: Docker simplifies the setup process for Jupyter Lab and other data science libraries, saving time by avoiding the need to manually install and configure packages and dependencies.</p> </li> <li> <p>Portability: Once a Docker container is created, it can be shared with colleagues or collaborators, ensuring that everyone uses the same environment and eliminates \"it works on my machine\" issues.</p> </li> <li> <p>Scalability: Docker enables easy scaling and management of multiple containers, which is useful for large datasets or distributed computing tasks in data science workflows.</p> </li> <li> <p>Integration with CI/CD: Docker containers can be integrated into continuous integration and deployment pipelines, ensuring that your data science projects are always tested and deployed in consistent environments.</p> </li> <li> <p>Efficiency: Containers are lightweight compared to traditional virtual machines, allowing faster startup times and efficient use of system resources, making them ideal for data science tasks where resources may vary.</p> </li> </ol> <p>By using Docker with Jupyter Lab, you streamline your development process, improve consistency across environments, and enhance collaboration.</p>"},{"location":"overview/architecture/#what-is-jupyter-lab","title":"What is Jupyter Lab?","text":"<p>Jupyter Lab is an open-source, interactive development environment (IDE) designed for data science, machine learning, and scientific computing. It provides a web-based interface where users can create and manage Jupyter notebooks, text editors, terminals, and custom dashboards, all within a single unified environment.</p>"},{"location":"overview/architecture/#key-features-of-jupyter-lab","title":"Key Features of Jupyter Lab:","text":"<ul> <li> <p>Interactive Notebooks: Users can create and execute Jupyter notebooks, which combine code, visualizations, and documentation in a single document.</p> </li> <li> <p>Multi-File Interface: Jupyter Lab allows for working with multiple files simultaneously, such as notebooks, scripts, and data files, making it easier to organize and manage projects.</p> </li> <li> <p>Extensibility: Jupyter Lab supports a wide range of plugins and extensions, allowing customization to suit various workflows, such as adding support for new languages or advanced visualization tools.</p> </li> <li> <p>Real-Time Collaboration: It facilitates collaboration by allowing multiple users to work on the same notebook in real-time (with additional plugins).</p> </li> <li> <p>Support for Multiple Languages: While Jupyter Lab is most commonly used with Python, it supports multiple languages such as R, Julia, and others via kernels, making it flexible for a variety of data science and scientific computing tasks.</p> </li> <li> <p>Rich Visualizations: It integrates well with libraries like Matplotlib, Plotly, and others to display interactive and rich visualizations directly within the notebook.</p> </li> <li> <p>Integration with Data Science Tools: Jupyter Lab can integrate seamlessly with data science libraries like Pandas, NumPy, SciPy, and TensorFlow, making it a powerful tool for analysis and modeling.</p> </li> </ul> <p>Overall, Jupyter Lab is an enhanced, feature-rich interface for Jupyter notebooks that streamlines the process of data analysis, visualization, and reporting in one place.</p> <ul> <li>visit Jupyter Official Website for more information.</li> </ul> <p></p>"},{"location":"overview/architecture/#discuss","title":"Discuss:","text":""},{"location":"overview/architecture/#qa-container-architecture-jupyter-lab","title":"Q&amp;A: Container Architecture &amp; Jupyter Lab","text":""},{"location":"overview/architecture/#q1-what-is-the-main-difference-between-containers-and-virtual-machines","title":"Q1: What is the main difference between containers and virtual machines?","text":"<p>A1: The main difference between containers and virtual machines lies in how they implement virtualization. Virtual machines virtualize an entire system, including the hardware, using a hypervisor, and each VM includes its own operating system. Containers, on the other hand, virtualize only the software layers above the operating system, sharing the host OS's kernel. As a result, containers are more lightweight and efficient, but rely on the host system's kernel for execution.</p>"},{"location":"overview/architecture/#q2-what-is-a-hypervisor-and-what-are-the-two-types-of-hypervisors","title":"Q2: What is a hypervisor, and what are the two types of hypervisors?","text":"<p>A2: A hypervisor is specialized software that emulates a client PC and all its hardware resources. It operates on physical computers (host machines). There are two types of hypervisors: 1. Hosted Hypervisor: Runs on top of an existing operating system and does not directly manage hardware drivers. 2. Bare-metal Hypervisor: Runs directly on the host hardware without the need for an underlying operating system.</p>"},{"location":"overview/architecture/#q3-why-should-docker-containers-be-used-for-data-development-with-jupyter-lab","title":"Q3: Why should Docker containers be used for data development with Jupyter Lab?","text":"<p>A3: Docker containers offer several advantages for data development with Jupyter Lab: - Isolation: Ensures that Jupyter Lab and its dependencies are isolated from other software. - Reproducibility: The environment is the same across different systems, ensuring code consistency. - Consistency: Encapsulates all dependencies and configurations, ensuring a consistent development environment. - Easy Setup: Simplifies the installation and configuration of Jupyter Lab and related libraries. - Portability: Containers can be shared and used across different environments. - Scalability: Easily scale and manage containers, ideal for large datasets and distributed computing tasks. - Efficiency: Lightweight containers are faster to start and use fewer resources compared to virtual machines.</p>"},{"location":"overview/architecture/#q4-what-is-jupyter-lab-and-what-are-its-key-features","title":"Q4: What is Jupyter Lab, and what are its key features?","text":"<p>A4: Jupyter Lab is an open-source, interactive development environment for data science, machine learning, and scientific computing. It provides a web-based interface for creating and managing Jupyter notebooks, text editors, terminals, and custom dashboards. </p> <p>Key features include: - Interactive Notebooks: Combine code, visualizations, and documentation. - Multi-File Interface: Work with multiple files such as notebooks, scripts, and data files simultaneously. - Extensibility: Support for plugins and extensions to customize the environment. - Real-Time Collaboration: Allows multiple users to work on the same notebook in real-time. - Support for Multiple Languages: Supports Python, R, Julia, and others. - Rich Visualizations: Integrates with visualization libraries like Matplotlib and Plotly. - Integration with Data Science Tools: Seamless integration with libraries like Pandas, NumPy, SciPy, and TensorFlow.</p>"},{"location":"part_1_installation/1_install_python/","title":"Section 1  Setup Environment","text":""},{"location":"part_1_installation/1_install_python/#install-native-python","title":"Install Native Python","text":"<p>Step 1. Downloading the pthon installer 1. Go to official  https://www.python.org/downloads/ 2. Download the latest or previous versions of Python for Windows 64bit (3.13,3.12), including installers</p> <p> </p> <ol> <li>After the installer is downloaded, double-click the <code>.exe</code> file <code>python-3.13.1-amd64.exe, python-3.12.8-amd64.exe</code> </li> <li>Select the install launcher for all user, eanbles all users for the computer to access to the python   </li> <li>Select the python.exe to PATH checkbox, which enables users to launch python from command line </li> </ol> <p>Python Directory</p> <p>Before you start, learning about python directory: locate the Python installation directory on your system. The following directories are examples of the default directory paths:</p> <p>C:\\Program Files\\Python313: if you selected (User admin priviledges)  Install for all users during installation, then the directory will be system wide C:\\Users\\\"username\"\\AppData\\Local\\Programs\\Python\\Python313: if you didn\u2019t select Install for all users during installation, then the directory will be in the Windows user path</p>"},{"location":"part_1_installation/1_install_python/#discuss-python-environment","title":"Discuss: Python Environment:","text":""},{"location":"part_1_installation/1_install_python/#start-install-process","title":"Start Install process","text":"<ol> <li>Installing  Successfull install </li> </ol>"},{"location":"part_1_installation/1_install_python/#setup-python-environment","title":"Setup python environment","text":""},{"location":"part_1_installation/1_install_python/#verify-python","title":"Verify python","text":"<p>we can verify python installation by command line. Start to use command line from windows. open windows cmd or powershell. run command belows <pre><code>python --version\nwhere python\n</code></pre> </p>"},{"location":"part_1_installation/1_install_python/#install-package-with-command-pyhon-m-pip","title":"Install package with command pyhon -m pip","text":"<p><pre><code>python -m pip install tersorflow\n</code></pre> from output below there is ERROR: say Could not find a version that satisfies the requirement tensorflow version  </p> <p>let goto https://pypi.org/project/tensorflow/ </p> <p>Interesting we can install numpy package: The error occurs because TensorFlow currently does not support Python 3.13. TensorFlow's development cycles typically lag behind the latest Python versions, and support is usually added after thorough testing.</p> <p></p>"},{"location":"part_1_installation/1_install_python/#next-step-we-reinstall-python-312","title":"Next Step: we reinstall python 3.12","text":"<p>we want to install tensorflow again. We will install tersorflow to python 3.12. Let download python 3.12: </p> <p>continue process installation: </p> <p></p> <p>Success install: </p> <p>Let Change python environment to python312: </p> <p>Verify new python version and install tensorflow again: </p> <p>we will see the result: Successfully install package: </p>"},{"location":"part_1_installation/1_install_python/#create-python-project","title":"Create python project","text":"<p>create normal folder and change folder to python project with environment</p> <ol> <li>create folder with <code>mkdir</code> command and move to folder with <code>cd</code> command  </li> <li>create python virtal enviroment with command <code>python -m venv myvenv</code> in project directory </li> <li>activate pthon envionment with <code>.\\myenv\\Scripts\\activate.bat</code>  we will see the indicator <code>(myenv)</code> whick show the corrent environment we reside.</li> </ol> <p>Discuss: install package in environment  isolation: </p>"},{"location":"part_1_installation/1_install_python/#key-python-package-for-datascience","title":"Key Python Package for DataScience","text":"<p>key packages in Python for Data Science and Machine.  1. Pandas 2. Numpy 3. Scikit Learn 4. Matplotlib 5. Seaborn</p> <p>We have a foundation in Python, so it's essential to explore various Python packages such as numpy, pandas, and matplotlib, as well as Python modules like math, random, and datetime. In the Python ecosystem, both modules and packages serve as tools to organize and structure code based on different purposes.</p> <p></p>"},{"location":"part_1_installation/1_install_python/#difference-between-packages-and-modules-in-python","title":"Difference Between Packages and Modules in Python","text":"Aspect Module Package Definition A single Python file containing code (functions, classes, etc.). A collection of modules organized in a directory with an <code>__init__.py</code> file. Structure A <code>.py</code> single file. A directory containing an <code>__init__.py</code> file and one or more modules. Purpose To group related code together. To organize multiple modules into a hierarchical structure. Example <code>math</code>, <code>random</code>, <code>datetime</code> <code>numpy</code>, <code>pandas</code>, <code>matplotlib</code> Use Case Lightweight organization for smaller functionality. Manage larger projects with complex dependencies and modularity. How to import import module_name import package_name.module_name"},{"location":"part_1_installation/1_install_python/#key-concepts-and-purposes","title":"Key Concepts and Purposes","text":""},{"location":"part_1_installation/1_install_python/#modules","title":"Modules:","text":"<ul> <li>Provide a way to reuse code in a single file.</li> <li>Focus on a specific functionality (e.g., math operations, random number generation).</li> <li>Example: Importing a single module: <pre><code>  import math\n  print(math.sqrt(16))  # Output: 4.0\n</code></pre></li> </ul>"},{"location":"part_1_installation/1_install_python/#packages","title":"Packages:","text":"<ul> <li>Group related modules together to create a larger, well-organized library.</li> <li>Enable a hierarchical structure for large-scale applications.</li> <li>Example: Importing a module from a package: <pre><code>  import numpy.linalg\n  print(numpy.linalg.norm([3, 4]))  # Output: 5.0\n</code></pre></li> </ul>"},{"location":"part_1_installation/2_install_conda/","title":"Section 2 Conda Environment","text":"<p>conda is a powerful package, dependency, and environment management tool widely used in Python programming, especially for scientific computing and data analysis. It is commonly associated with the Anaconda (full) and Miniconda (minimal) distributions.</p>"},{"location":"part_1_installation/2_install_conda/#objective","title":"Objective","text":"<ul> <li> <p>Successfully Install a Conda Environment   Ensure the Conda environment is installed and properly configured for use.</p> </li> <li> <p>Understand Using Conda Prompt and JupyterLab   Learn how to utilize the Conda prompt for managing environments and running JupyterLab for interactive development.</p> </li> </ul>"},{"location":"part_1_installation/2_install_conda/#key-features-of-conda","title":"Key Features of Conda","text":""},{"location":"part_1_installation/2_install_conda/#1-environment-management","title":"1. Environment Management:","text":"<ul> <li>Create isolated environments for different projects, each with its own Python version and packages.</li> <li>Avoid version conflicts and dependency issues.</li> </ul>"},{"location":"part_1_installation/2_install_conda/#2-package-management","title":"2. Package Management:","text":"<ul> <li>Install, update, and manage packages seamlessly.</li> <li>Supports Python and non-Python packages.</li> </ul>"},{"location":"part_1_installation/2_install_conda/#3-cross-platform","title":"3. Cross-Platform:","text":"<ul> <li>Works on Linux, macOS, and Windows.</li> </ul>"},{"location":"part_1_installation/2_install_conda/#4-precompiled-packages","title":"4. Precompiled Packages:","text":"<ul> <li>Provides precompiled binaries, reducing installation errors.</li> </ul>"},{"location":"part_1_installation/2_install_conda/#install-anaconda-full-installation","title":"Install Anaconda (Full installation):","text":"<ul> <li>Download from Anaconda Office Site </li> <li>Download Anacona Installers 64-bit Graphical Installer </li> <li>Download success </li> <li>Start installation </li> <li>Accept Licence </li> <li>Install Just Me mode</li> </ul>"},{"location":"part_1_installation/2_install_conda/#installation-for-a-single-user-normal-user","title":"Installation for a Single User (Normal User)","text":"<ul> <li>Scope: Installs Anaconda only for the current user, meaning other users on the same computer won\u2019t have access to the installation.</li> <li>Permissions: No need for administrator privileges.</li> <li>Directory: The installation is done in the user's home directory (e.g., <code>C:\\Users\\YourUsername\\Anaconda3</code>).</li> <li>Environment Management: Can create environments and install packages only for that specific user.</li> <li>Use Case: Ideal for personal use or when we don't have administrative access to the machine (e.g., in a corporate environment).</li> </ul>"},{"location":"part_1_installation/2_install_conda/#steps","title":"Steps:","text":"<ol> <li>Choose the \"Just Me\" option during installation.</li> <li>Follow the on-screen instructions.</li> </ol> <p> * Install location. Conda will install in user folder  * Select options [/] Register Anaconda3, and [/] Clear the package cache upon completion</p> <p> * Wait installing  * Complete install</p> <p></p>"},{"location":"part_1_installation/2_install_conda/#open-anaconda-navigator-app","title":"Open Anaconda Navigator App","text":"<ul> <li>Open anaconda prompt from Navigator </li> <li>Run <code>conda init</code> </li> </ul>"},{"location":"part_1_installation/2_install_conda/#why-we-have-to-run-conda-init-after-installation","title":"Why We Have to Run <code>conda init</code> After Installation","text":"<p>Running <code>conda init</code> after installing Anaconda (or Miniconda) is necessary to configure your shell environment so that Conda commands can be recognized and executed correctly in the terminal.</p>"},{"location":"part_1_installation/2_install_conda/#1-modifying-shell-configuration","title":"1. Modifying Shell Configuration","text":"<ul> <li>Purpose: <code>conda init</code> modifies the shell's configuration files (like <code>.bashrc</code>, <code>.zshrc</code>, <code>.bash_profile</code>, etc.) to add the necessary environment variables and configurations.</li> <li>Effect: This ensures that the <code>conda</code> command is available globally in the terminal without needing to specify the full path to the Anaconda installation.</li> </ul>"},{"location":"part_1_installation/2_install_conda/#2-activating-conda-base-environment-automatically","title":"2. Activating Conda Base Environment Automatically","text":"<ul> <li>By running <code>conda init</code>, Conda sets up the shell to automatically activate the base environment when a terminal is opened. This way, you don\u2019t need to manually activate the base environment every time you start a new terminal session.</li> </ul> <p>Example:   - Without <code>conda init</code>, you'd need to type <code>conda activate</code> manually every time.   - After running <code>conda init</code>, the terminal will automatically activate the base environment.</p>"},{"location":"part_1_installation/2_install_conda/#3-ensuring-proper-path-configuration","title":"3. Ensuring Proper PATH Configuration","text":"<ul> <li>Conda needs to be added to the system <code>PATH</code> for it to be accessible in any terminal session. <code>conda init</code> ensures that the appropriate paths are set up.</li> </ul>"},{"location":"part_1_installation/2_install_conda/#4-enabling-conda-environment-activation-in-any-shell","title":"4. Enabling Conda Environment Activation in Any Shell","text":"<ul> <li>Conda init ensures compatibility across different shells (bash, zsh, fish, etc.) by setting up the appropriate configurations for each shell. This makes it easier to use Conda on any system with different shell environments.</li> </ul>"},{"location":"part_1_installation/2_install_conda/#in-summary","title":"In Summary:","text":"<p>Running <code>conda init</code> ensures that: - Conda's commands are available in your terminal. - The base environment is automatically activated. - The system is configured to manage multiple environments effectively across different shell types.</p> <p>We only need to run <code>conda init</code> once, after which it will modify the necessary files to enable seamless use of Conda.</p>"},{"location":"part_1_installation/2_install_conda/#fix-permision","title":"Fix Permision","text":"<pre><code>PermissionError: [Errno 13] Permission denied: 'C:\\\\Users\\\\sysadmin\\\\AppData\\\\Roaming\\\\jupyter\\\\runtime\\\\jpserver-20464-open.html'\n</code></pre> <ul> <li>Close anaconda Desktop and Re open again with Administrator</li> <li>Open anaconda prompt:</li> </ul> <ul> <li>Copy link to browser</li> </ul> <ul> <li>Jupyter lab web</li> </ul>"},{"location":"part_1_installation/2_install_conda/#update-jupyter-lab","title":"Update Jupyter Lab","text":"<p>Run this command to ensure your JupyterLab and Jupyter Server are up to date with the latest features, improvements, and security patches.  <pre><code>pip install --upgrade jupyterlab jupyter_server\n</code></pre></p> <p></p>"},{"location":"part_1_installation/2_install_conda/#create-conda-environment-and-activate","title":"Create Conda Environment and Activate","text":"<ul> <li>Start from (base) environment of Conda <pre><code>(base) conda create -n myenv python=3.12\n</code></pre></li> <li>This creates an environment named <code>myenv</code> with Python version 3.12 <pre><code>(base) conda activate myenv\n</code></pre></li> </ul> <p> Accept [y] then enter:</p> <p></p> <p>install jupyterlab jupyter-server in myenv <pre><code>(myenv) C:\\Users\\sysadmin&gt;pip install --upgrade jupyterlab jupyter-server\n</code></pre></p>"},{"location":"part_1_installation/2_install_conda/#summary-of-common-conda-commands","title":"Summary of Common Conda Commands","text":"Command Description <code>conda create -n &lt;env_name&gt; python=X</code> Create a new Conda environment with Python version <code>X</code>. <code>conda activate &lt;env_name&gt;</code> Activate the specified Conda environment. <code>conda deactivate</code> Deactivate the current Conda environment. <code>conda env list</code> List all available Conda environments. <code>conda remove -n &lt;env_name&gt; --all</code> Delete a specified Conda environment and all its packages. <code>conda install &lt;package_name&gt;</code> Install a package into the currently active Conda environment. <code>conda update &lt;package_name&gt;</code> Update a specific package in the active Conda environment. <code>conda update conda</code> Update Conda to the latest version. <code>conda list</code> List all installed packages in the active Conda environment. <code>conda search &lt;package_name&gt;</code> Search for a package in Conda repositories. <code>conda info</code> Display information about the Conda installation. <code>conda clean --all</code> Remove unnecessary files, caches, and unused packages to free up space. <code>conda export &gt; environment.yml</code> Export the active environment to a <code>.yml</code> file for sharing or backup. <code>conda env create -f environment.yml</code> Create an environment from a <code>.yml</code> file. <code>conda config --add channels &lt;name&gt;</code> Add a new channel (repository) to Conda configuration. <code>conda config --show</code> Display the current Conda configuration. <code>conda uninstall &lt;package_name&gt;</code> Uninstall a specific package from the active Conda environment."},{"location":"part_1_installation/3_install_docker/","title":"Section 3 Install Docker Desktop on Windows","text":""},{"location":"part_1_installation/3_install_docker/#how-to-install-docker-desktop-on-windows","title":"How to Install Docker Desktop on Windows","text":""},{"location":"part_1_installation/3_install_docker/#prerequisites","title":"Prerequisites","text":"<ol> <li> <p>Supported Windows Version:</p> <ul> <li>Windows 10 64-bit: Pro, Enterprise, or Education (2004 or later).</li> <li>Windows 11: Home, Pro, or Enterprise.</li> </ul> </li> <li> <p>System Requirements:</p> <ul> <li>WSL 2 (Windows Subsystem for Linux) feature enabled.</li> <li>Hardware virtualization enabled in the BIOS.</li> <li>Minimum of 4GB RAM.</li> </ul> </li> <li> <p>Admin Rights:</p> <ul> <li>Administrator access is required for installation.</li> </ul> </li> </ol>"},{"location":"part_1_installation/3_install_docker/#steps-to-install-docker-desktop","title":"Steps to Install Docker Desktop","text":"<ol> <li> <p>Download Docker Desktop:</p> <ul> <li>Visit the Docker Desktop Download Page and download the installer for Windows.</li> </ul> </li> <li> <p>Run the Installer:</p> <ul> <li>Double-click the downloaded <code>.exe</code> file.</li> <li>Follow the installation wizard instructions.</li> </ul> </li> <li> <p>Enable WSL 2:</p> <ul> <li>During installation, ensure WSL 2 is selected as the default backend.</li> </ul> </li> <li> <p>Restart Your System:</p> <ul> <li>After installation, restart your computer to finalize the setup.</li> </ul> </li> <li> <p>Start Docker Desktop:</p> <ul> <li>Search for \"Docker Desktop\" in the Start menu and launch the application.</li> <li>Docker Desktop will initialize and verify system compatibility.</li> </ul> </li> <li> <p>Sign In to Docker Hub:</p> <ul> <li>Optional: Sign in with your Docker Hub account or create a new one.</li> </ul> </li> </ol>"},{"location":"part_1_installation/3_install_docker/#step1-enable-wsl2","title":"Step1: Enable WSL2","text":"<p>Open PowerShell as Administrator </p> <p></p> <p><pre><code>wsl --install\n</code></pre> This command will:</p> <ul> <li>install linux (ubuntu) on windows</li> </ul> <p>Access to ubuntu: Search  'ubuntu\" </p> <p>Open Ubuntu Application: will open ubuntu shell</p> <p></p> <p>Run: update command <pre><code>cat /etc/lsb-release\napt update &amp;&amp; apt full-upgrade -y\n</code></pre></p> <p>Step 2: Install Docker Desktop 1. Download Docker Desktop for windows </p> <p>2 click installer  </p> <p> wait for install</p> <p>3 Success screen, Click close </p> <p>Step3: verify Docker is install correctly,  open a terminal (Command promp or PowerShell)</p> <p> <pre><code>docker --version\n</code></pre></p> <p>4 Open Docker Desktop </p> <p>Accept  Docker desktop  Enable Terminal </p> <p></p>"},{"location":"part_1_installation/3_install_docker/#ensure-wsl2-install","title":"Ensure WSL2 install","text":"<p>we can use command below to list WSL install <pre><code>&gt; wsl --set-default-version 2\n&gt; wsl --list --verbose\n  NAME              STATE           VERSION\n* Ubuntu            Stopped         2\n  docker-desktop    Stopped         2\n</code></pre> - Version 2 indicated instance use WSL2 architecture, which includes a real linux kernel - docker-desktop  is installed in system - state <code>Stopped</code> mean WSL distribution not running</p>"},{"location":"part_1_installation/3_install_docker/#start-wsl-instance","title":"Start wsl instance","text":"<ul> <li>Start Ubuntu install by command line <pre><code>&gt; wsl -d Ubuntu\n</code></pre></li> </ul> <ul> <li>Start docker-desktop wsl instance by start docker-destop application</li> <li>after start docker-desktop application, open terminal run <code>wsl --list --verbose</code></li> <li>See State of WSL is running</li> </ul>"},{"location":"part_2_docker_jupyter/1_dockercomposejupyter/","title":"Section 1 Docker Engine for Data Science","text":"<p>To design a Docker container for data science that integrates with Jupyter Lab, you can create a custom Dockerfile. This container will include common tools and libraries used in data science, such as Python, Jupyter Lab, and essential data science packages like numpy, pandas, matplotlib, and scikit-learn.</p>"},{"location":"part_2_docker_jupyter/1_dockercomposejupyter/#back-to-basic-of-container","title":"Back to Basic of Container","text":"<p>Before diving into commands, it's essential to understand some basic concepts:</p> <ul> <li>Images: A Docker image is a read-only template used to create containers. It can include the OS, application code, and libraries.</li> <li>Containers: A Docker container is a lightweight, executable package that includes everything needed to run a piece of software, such as the code, runtime, libraries, and system tools.</li> </ul> <p></p>"},{"location":"part_2_docker_jupyter/1_dockercomposejupyter/#what-is-dockerfile","title":"What is Dockerfile?","text":"<p>A Dockerfile is a script that contains a series of instructions on how to build a Docker image. It defines the steps needed to set up a containerized environment, specifying the base image, installing dependencies, copying files, and configuring how the container will run.</p>"},{"location":"part_2_docker_jupyter/1_dockercomposejupyter/#what-is-a-container","title":"What is a Container?","text":"<p>The concept of containers originated in the 1970s. Think of a container as an isolated working environment\u2014a virtual server that can be configured from scratch. You can define its properties, such as the operating system, Python interpreter version, and required library dependencies. Containers run by utilizing your machine's resources.</p> <p>One key feature of a container is that it does not have access to your storage unless explicitly granted permission. A common best practice is to mount specific folders that should be accessible within the container.</p> <p>Key Steps in Working with Containers: 1. Define the environment: Create a Dockerfile to specify the container's setup. 2. Build the image: Generate a Docker image based on the Dockerfile. 3. Run the container: Create and launch a container using the Docker image.</p> <p>This process is highly shareable, enabling team members to replicate the environment consistently. Containers can be recreated as needed, ensuring reproducibility and efficiency in development workflows.</p>"},{"location":"part_2_docker_jupyter/1_dockercomposejupyter/#create-a-docker-container-for-data-science-with-jupyter-lab","title":"Create a Docker Container for Data Science with Jupyter Lab","text":""},{"location":"part_2_docker_jupyter/1_dockercomposejupyter/#step1-create-a-dockerfile-first-create-a-directory-for-your-project-and-create-a-dockerfile-within-that-directory-heres-how-to-set-it-up","title":"Step1 Create a Dockerfile: First create a directory for your project and create a Dockerfile within that directory. Here\u2019s how to set it up:","text":"<ul> <li>Create folder dockerjupyter1</li> <li>Create Dockerfile with content: inside dockerjupyter1 folder</li> </ul> <p>Dockerfile<pre><code># Use Python 3.12 as the base image\nFROM python:3.12-slim\n\n# Set the working directory in the container\nWORKDIR /app\n\n# Install system dependencies for data science packages\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    build-essential \\\n    libcurl4-openssl-dev \\\n    libssl-dev \\\n    libffi-dev \\\n    &amp;&amp; apt-get clean\n\n# Install Jupyter Lab and common data science packages\nRUN pip install --no-cache-dir \\\n    jupyterlab \\\n    numpy \\\n    pandas \\\n    matplotlib \\\n    scikit-learn \\\n    seaborn \\\n    scipy \\\n    plotly \\\n    &amp;&amp; pip install --upgrade pip\n\n# Expose Jupyter Lab's default port\nEXPOSE 8888\n\n# Set the default command to launch Jupyter Lab\nCMD [\"jupyter\", \"lab\", \"--ip='*'\", \"--port=8888\", \"--no-browser\", \"--allow-root\"]\n</code></pre> Discuss: mount (connect) file from host system into Docker container </p>"},{"location":"part_2_docker_jupyter/1_dockercomposejupyter/#explain-dockerfile","title":"Explain: Dockerfile","text":"<ul> <li>Click here to read explaination Dockerfile</li> </ul>"},{"location":"part_2_docker_jupyter/1_dockercomposejupyter/#step2-build-and-run","title":"Step2 Build and Run","text":"<p>we have to understand 2 step (Build &amp; Run) * Step2.1 Build the Docker image: <pre><code>docker build -t data-science-jupyterlab .\n</code></pre></p>"},{"location":"part_2_docker_jupyter/1_dockercomposejupyter/#explanation","title":"Explanation:","text":"<ul> <li>-t data-science-jupyterlab: Tags the image with the name data-science-jupyterlab.</li> <li>.: Specifies the current directory (which should contain your Dockerfile).</li> </ul> <p>This way, any Jupyter notebooks you have in your current directory will be accessible from within the Docker container.</p> <p></p> <p>List image from build: <pre><code>&gt; docker image ls\n</code></pre> </p> <ul> <li> <p>Step2.2 Run image:</p> <ul> <li>Run the Docker Container: For linux, macos <pre><code>docker run -p 8888:8888 -d --name data-science-container -v $(pwd):/app data-science-jupyterlab\n</code></pre></li> <li> <p>Run the Docker Container: For Command prompt <pre><code>docker run -p 8888:8888 -d --name data-science-container -v %cd%:/app data-science-jupyterlab\n</code></pre></p> </li> <li> <p>Run the Docker Container: For ${PWD} <pre><code>docker run -p 8888:8888 -d --name data-science-container -v ${PWD}:/app data-science-jupyterlab\n</code></pre></p> </li> </ul> </li> </ul>"},{"location":"part_2_docker_jupyter/1_dockercomposejupyter/#explanation_1","title":"Explanation:","text":"<ul> <li>docker run: This command is used to create and start a new container from an image.</li> <li>-p 8888:8888: Maps port 8888 on your host machine to port 8888 inside the container, which is the default port for Jupyter Lab.</li> <li>-d: Runs the container in detached mode (in the background).</li> <li>--name data-science-container: Assigns a name (data-science-container) to the container.</li> <li>-v $(pwd):/app: Mounts the current directory ($(pwd)) to the /app directory inside the container, so your Jupyter notebooks in the current directory are accessible inside the container.</li> <li>data-science-jupyterlab: Specifies the name of the Docker image to use.</li> </ul> <p><pre><code>docker logs data-science-container\n\n http://localhost:8888/lab?token=8bef2e4874327fd529617d927d61caab9a84500595fef369\n</code></pre> </p>"},{"location":"part_2_docker_jupyter/1_dockercomposejupyter/#easy-access-to-jupyter-lab","title":"Easy Access to Jupyter lab","text":"<ul> <li>copy url open in browser http://localhost:8888/lab?token=8bef2e4874327fd529617d927d61caab9a84500595fef369</li> </ul>"},{"location":"part_2_docker_jupyter/1_dockercomposejupyter/#clean-up-container-before-continue","title":"Clean up container before continue...","text":"<ul> <li>Stop Container  </li> <li>Clean docker container</li> <li>Remove image</li> </ul>"},{"location":"part_2_docker_jupyter/1_dockercomposejupyter/#discuss","title":"Discuss:","text":"<ul> <li>Stop a Running Container <pre><code>docker stop &lt;container_name_or_id&gt;\n</code></pre></li> <li> <p>Replace  with the name or ID of the container you want to stop. <li> <p>Clean Docker Containers <pre><code>docker rm &lt;container_name_or_id&gt;\n</code></pre></p> </li> <li> <p>Remove a Specific Container</p> </li> <li> <p>Remove All Stopped Containers: <pre><code>docker container prune\n</code></pre></p> </li>"},{"location":"part_2_docker_jupyter/2_dockerfile1/","title":"Section 2 Dockerfile for Data Science Environment with Jupyter Lab","text":"Dockerfile<pre><code># Use Python 3.12 as the base image\nFROM python:3.12-slim\n\n# Set the working directory in the container\nWORKDIR /app\n\n# Install system dependencies for data science packages\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    build-essential \\\n    libcurl4-openssl-dev \\\n    libssl-dev \\\n    libffi-dev \\\n    &amp;&amp; apt-get clean\n\n# Install Jupyter Lab and common data science packages\nRUN pip install --no-cache-dir \\\n    jupyterlab \\\n    numpy \\\n    pandas \\\n    matplotlib \\\n    scikit-learn \\\n    seaborn \\\n    scipy \\\n    plotly \\\n    statsmodels \\\n    &amp;&amp; pip install --upgrade pip\n\n# Expose Jupyter Lab's default port\nEXPOSE 8888\n\n# Set the default command to launch Jupyter Lab\nCMD [\"jupyter\", \"lab\", \"--ip='*'\", \"--port=8888\", \"--no-browser\", \"--allow-root\"]\n</code></pre> <p>This Dockerfile creates a containerized environment for data science workflows, including the installation of Jupyter Lab and common data science packages.</p>"},{"location":"part_2_docker_jupyter/2_dockerfile1/#1-use-python-312-as-the-base-image","title":"1. Use Python 3.12 as the base image","text":"<p>The base image is set to Python 3.12 with a slim variant to reduce image size.</p> <pre><code>FROM python:3.12-slim\n</code></pre> <p>Click link to see specification of python3.12-slim page</p>"},{"location":"part_2_docker_jupyter/2_dockerfile1/#2-set-the-working-directory-in-the-container","title":"2. Set the working directory in the container","text":"<p>This instruction sets the working directory to /app inside the container. All subsequent commands will be run from this directory. <pre><code>WORKDIR /app\n</code></pre></p>"},{"location":"part_2_docker_jupyter/2_dockerfile1/#3-install-system-dependencies-for-data-science-packages","title":"3. Install system dependencies for data science packages","text":"<p>This step installs system dependencies required for compiling and installing various Python packages used in data science. <pre><code>RUN apt-get update &amp;&amp; apt-get install -y \\\n    build-essential \\\n    libcurl4-openssl-dev \\\n    libssl-dev \\\n    libffi-dev \\\n    &amp;&amp; apt-get clean\n</code></pre></p>"},{"location":"part_2_docker_jupyter/2_dockerfile1/#4-install-jupyter-lab-and-common-data-science-packages","title":"4. Install Jupyter Lab and common data science packages","text":"<p>The following Python packages are installed:  </p> <ol> <li>Jupyter Lab: The web-based interactive development environment for notebooks.</li> <li>Data Science Libraries: Including numpy, pandas, matplotlib, scikit-learn, seaborn, scipy, and plotly. This installation is done using pip to ensure that packages are installed without caching. <pre><code>RUN pip install --no-cache-dir \\\n    jupyterlab \\\n    numpy \\\n    pandas \\\n    matplotlib \\\n    scikit-learn \\\n    seaborn \\\n    scipy \\\n    plotly \\\n    &amp;&amp; pip install --upgrade pip\n</code></pre></li> </ol>"},{"location":"part_2_docker_jupyter/2_dockerfile1/#5-expose-jupyter-labs-default-port","title":"5. Expose Jupyter Lab's default port","text":"<p>Expose port 8888, the default port that Jupyter Lab listens on, making it accessible from outside the container. <pre><code>EXPOSE 8888\n</code></pre></p>"},{"location":"part_2_docker_jupyter/2_dockerfile1/#6-set-the-default-command-to-launch-jupyter-lab","title":"6. Set the default command to launch Jupyter Lab","text":"<p>The default command launches Jupyter Lab with the following params options:</p> <ul> <li>--ip='*': Allows connections from any IP address.</li> <li>--port=8888: Specifies the port to run Jupyter Lab on.</li> <li>--no-browser: Prevents the automatic opening of a browser.</li> <li>--allow-root: Allows running Jupyter Lab as the root user inside the container.</li> </ul>"},{"location":"part_2_docker_jupyter/2_dockerfile1/#7-complete-cmd-command","title":"7. Complete CMD command","text":"<pre><code>CMD [\"jupyter\", \"lab\", \"--ip='*'\", \"--port=8888\", \"--no-browser\", \"--allow-root\"]\n</code></pre>"},{"location":"part_2_docker_jupyter/2_dockerfile1/#format-of-cmd","title":"Format of CMD","text":"<p>Format of CMD:</p> <p><pre><code>CMD command param1 param2\n</code></pre> This is executed in the shell (/bin/sh -c).</p> <ul> <li>Exec form (recommended):</li> </ul> <p><pre><code>CMD [\"executable\", \"param1\", \"param2\"]\n</code></pre> This does not invoke a shell, which prevents issues like signal handling and allows the executable to run directly.</p>"},{"location":"part_2_docker_jupyter/2_dockerfile1/#summary-of-workflow","title":"Summary of Workflow:","text":"<ol> <li>Base Image: Python 3.12-slim for a lightweight container.</li> <li>System Dependencies: Essential packages for compiling and installing Python packages.</li> <li>Python Packages: Installs Jupyter Lab and essential libraries for data science.</li> <li>Expose Port: Makes Jupyter Lab accessible at port 8888.</li> <li>Start Jupyter Lab: The container automatically starts Jupyter Lab with the appropriate configurations when run.</li> </ol>"},{"location":"part_2_docker_jupyter/3_docker_compose/","title":"Section 3 Docker compose with Dockerfile","text":"<ul> <li>Inside folder <code>dockerjupyterlab1</code></li> <li>Create folder <code>notebooks</code> to keep jupyternotebook</li> <li>Create docker-compose.yml in side folder  dockerjupyterlab1</li> </ul> <p>docker-compose.yml<pre><code>version: '3.8'\n\nservices:\n  data-science-jupyterlab:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    ports:\n      - \"8888:8888\" # Map Jupyter Lab's port to the host\n    volumes:\n      - ./notebooks:/app # Mount a local directory for persistent storage of notebooks\n    container_name: data-science-container\n    command: [\"jupyter\", \"lab\", \"--ip=0.0.0.0\", \"--port=8888\", \"--no-browser\", \"--allow-root\"]\n</code></pre> Show file browser: </p> <p><pre><code>docker compose up -d\n</code></pre>  The command <code>docker compose up -d</code> is used to start up a multi-container Docker application in detached mode what it does:</p> <ol> <li> <p>docker compose: This is the command used to work with Docker Compose, which is a tool for defining and managing multi-container Docker applications using a docker-compose.yml file.</p> </li> <li> <p>up: This command is used to create and start the containers defined in the docker-compose.yml file.</p> </li> <li> <p>-d (detached mode): This flag tells Docker Compose to run the containers in the background, so they don't block your terminal session.</p> </li> </ol> <p>Once this command is executed, Docker Compose will: - Look for a docker-compose.yml file in the current directory. - Create and start the services defined in the file. - Run them in the background, allowing you to continue working in the terminal.</p> <p><pre><code>docker compose ps \n</code></pre> </p> <p>The command docker compose ps is used to list the status of containers in a Docker Compose application. It provides information about the containers that are running, as defined in your docker-compose.yml file. Here\u2019s what it does:</p> <ol> <li> <p>docker compose: This is the command for managing multi-container applications using Docker Compose.</p> </li> <li> <p>ps: This command shows the status of the containers (running or stopped) that are part of the Docker Compose application.</p> </li> </ol> <p>When you run docker compose ps, it typically displays the following information:</p> <ul> <li>Container Name: The name of the container.</li> <li>State: Whether the container is up or stopped.</li> <li>Ports: The ports exposed by the container and how they are mapped to the host.</li> <li>Service Name: The name of the service as defined in the docker-compose.yml.</li> </ul>"},{"location":"part_2_docker_jupyter/3_docker_compose/#get-token-by-run-command","title":"Get Token by run command","text":"<p><pre><code>docker log data-science-container\n</code></pre> </p> <ul> <li>url http://127.0.0.1:8888/lab?token=9bd389dcd64754aed1506e1afe71a2d9e581c5ebd7126dba</li> </ul> <p></p> <p>Click open notebook </p> <p> command use tab to autocomplet module suggession   press tab after \".\"</p> code1.ipynb<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nx = np.random.random(100)\ny = np.random.random(100)\nplt.scatter(x,y)\n</code></pre> <p>Save file name: </p> <p>Play notebook: </p> <p>Save output to folder notebooks in system </p>"},{"location":"part_2_docker_jupyter/3_docker_compose/#discuss","title":"Discuss:","text":""},{"location":"part_2_docker_jupyter/3_docker_compose/#summary-sharing-development-with-teams","title":"Summary: Sharing development with teams","text":"<p>JupyterLab offers several benefits when it comes to sharing code among developers, particularly in collaborative data science and development environments:</p> <ol> <li> <p>Interactive Development: JupyterLab allows for interactive coding, where developers can experiment with code, view results instantly, and refine their work step-by-step. This facilitates better collaboration, as code execution and results are shared in real-time.</p> </li> <li> <p>Notebooks for Documentation and Code: Jupyter Notebooks combine code, visualizations, and markdown in one place. This makes it easier for developers to document their work alongside the code, creating a shared understanding of the project.</p> </li> <li> <p>Version Control Integration: JupyterLab integrates with version control systems like Git. This makes it easier for developers to share, track changes, and collaborate on the same project without worrying about overwriting code or losing work.</p> </li> <li> <p>Live Collaboration: Through extensions like JupyterLab Google Drive and JupyterLab RTC, multiple developers can work on the same notebook simultaneously. This real-time collaboration reduces the time needed for feedback loops and allows for better synchronization among team members.</p> </li> <li> <p>Environment Consistency: With features like JupyterHub, teams can create consistent development environments. Developers can run their notebooks in a shared environment that mirrors production, ensuring code runs the same way across all systems.</p> </li> <li> <p>Easy Sharing and Deployment: Developers can export notebooks as scripts, HTML, or PDF files, and easily share them with others. This makes it simple to distribute code, share results, or present findings to non-developers.</p> </li> <li> <p>Rich Data Visualization: JupyterLab integrates well with various visualization libraries (e.g., Matplotlib, Seaborn, Plotly), enabling developers to visualize data as they work. This shared visual context helps others better understand the work.</p> </li> <li> <p>Extensibility: Developers can add extensions to JupyterLab, such as code linters, debuggers, and integrated terminals. This customization enables teams to tailor the development environment to their needs and improve collaborative efficiency.</p> </li> </ol> <p>In summary, JupyterLab is beneficial for shared code development because it combines interactive coding, documentation, version control, and live collaboration, all within a flexible and extensible environment. This fosters productivity and streamlines collaboration among developers.</p>"},{"location":"part_2_docker_jupyter/3_docker_compose/#clone-example-git-repository","title":"Clone Example Git Repository","text":"<p>Repository <pre><code>git clone https://github.com/opendevbook/dockerjupyterlab\n</code></pre></p>"}]}